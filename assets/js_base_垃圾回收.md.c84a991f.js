import{_ as a,o as e,c as t,U as r}from"./chunks/framework.1bc6aac7.js";const b=JSON.parse('{"title":"垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"js/base/垃圾回收.md"}'),o={name:"js/base/垃圾回收.md"},i=r('<h1 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h1><h2 id="js-内存概念" tabindex="-1">js 内存概念 <a class="header-anchor" href="#js-内存概念" aria-label="Permalink to &quot;js 内存概念&quot;">​</a></h2><p>基础类型保存在栈中，系统会自动处理 引用类型，栈只保存堆的引用地址，值保存在堆中，垃圾回收针对的就是这个堆中的引用数据。</p><p>全局变量的引用类型，会一直存在应用的生命周期里，不会被垃圾回收清除，但可以把该变量置为 null，那么它将被垃圾回收器回收，即使它是全局对象的属性。</p><h2 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h2><p>变量声明、引用计数+1，变量被重新赋值-1，等于 0 时，被执行</p><h3 id="弊端" tabindex="-1">弊端 <a class="header-anchor" href="#弊端" aria-label="Permalink to &quot;弊端&quot;">​</a></h3><p>循环引用，导致引用无法清除</p><h2 id="标记清除法" tabindex="-1">标记清除法 <a class="header-anchor" href="#标记清除法" aria-label="Permalink to &quot;标记清除法&quot;">​</a></h2><p>垃圾回收器区将所有内存中的对象打上标记，然后从根结对象开始遍历，把还在上下文中的活动变量去掉标记，然后清理所有带标记的对象</p><h3 id="弊端-1" tabindex="-1">弊端 <a class="header-anchor" href="#弊端-1" aria-label="Permalink to &quot;弊端&quot;">​</a></h3><p>内存碎片化，分配速度慢。老生代会有标记整理算法去解决</p><h2 id="分代回收法" tabindex="-1">分代回收法 <a class="header-anchor" href="#分代回收法" aria-label="Permalink to &quot;分代回收法&quot;">​</a></h2><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><p>内部又分为使用区，空闲区</p><ol><li>新声明的对象都会放入使用区</li><li>垃圾回收时，会在使用区中寻找活动的对象，将其复制到空闲空间，如果标记有经历过一次的 scavenge 算法（垃圾回收）的则晋升到老生代的存储区里</li><li>然后清空使用区，将当前空闲区和使用对调</li></ol><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><p>使用标记清除法和标记整理算法回收</p>',18),l=[i];function h(s,n,d,c,_,p){return e(),t("div",null,l)}const q=a(o,[["render",h]]);export{b as __pageData,q as default};
