import{_ as e,o,c as i,U as a}from"./chunks/framework.1d5623bb.js";const h=JSON.parse('{"title":"vue双端diff算法","description":"","frontmatter":{},"headers":[],"relativePath":"面试经验/44-vue中diff算法.md"}'),d={name:"面试经验/44-vue中diff算法.md"},t=a('<h1 id="vue双端diff算法" tabindex="-1">vue双端diff算法 <a class="header-anchor" href="#vue双端diff算法" aria-label="Permalink to &quot;vue双端diff算法&quot;">​</a></h1><p>因为vue用的是mvvm的设计模式，当model更新后，会通过observer更新虚拟node，生成的新vnode与老vnode进行diff比较,再更新真实node。有些人会有疑问,为啥不直接更新node,要先更新vnode。比较简单的dom结构直接更新node效率是比较高，但页面结构复杂，数据又多时，这样就要写更多的代码，花费的时间也多，并且维护性也不高</p><ol><li>同层级比较</li><li>节点类型一样，当classname不一样会被判定不是同类型元素，删除重建</li></ol><h2 id="diff流程" tabindex="-1">diff流程 <a class="header-anchor" href="#diff流程" aria-label="Permalink to &quot;diff流程&quot;">​</a></h2><ol><li>数据更新，生成新的vnode，调用patch方法</li><li>用sameVnode判断两个node是否值得比较，不值得，就直接替换oldVnode</li></ol><blockquote><p>判断key是否相同与标签是否相同、是否都含有data属性、input类型是否相同这些</p></blockquote><ol start="3"><li>值得就调用patchVnode进行节点比较，该删删，改增增，还有简单的属性替换，</li><li>如果有子节点，就会调用updateChildren方法，就行双端diff算法比较</li><li>先新旧左边开始两两比较，如果不值得比较，两端右边开始比较，还不值，旧起始节点与新尾部节点比较，还不值，旧尾节点根新起始节点比较，还不值用key比较</li><li>直到旧节点全部比完，或者新节点全部比完。缺增多删，diff结束</li></ol>',7),l=[t];function f(n,r,_,s,c,u){return o(),i("div",null,l)}const v=e(d,[["render",f]]);export{h as __pageData,v as default};
