import{_ as l,o as i,c as e,U as a}from"./chunks/framework.1bc6aac7.js";const k=JSON.parse('{"title":"vite","description":"","frontmatter":{},"headers":[],"relativePath":"vite/vite实现原理.md"}'),o={name:"vite/vite实现原理.md"},t=a('<h1 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;vite&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：</p><ul><li><p>一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。</p></li><li><p>一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</p></li></ul><h2 id="双引擎架构" tabindex="-1">双引擎架构 <a class="header-anchor" href="#双引擎架构" aria-label="Permalink to &quot;双引擎架构&quot;">​</a></h2><h3 id="esbuild-性能利器" tabindex="-1">Esbuild - 性能利器 <a class="header-anchor" href="#esbuild-性能利器" aria-label="Permalink to &quot;Esbuild - 性能利器&quot;">​</a></h3><p>基于 Golang 开发的一款打包工具，相比传统的打包工具，主打性能优势，在构建速度上可以比传统工具快 10~100 倍。那么，它是如何达到这样超高的构建性能的呢？主要原因可以概括为 4 点。</p><ol><li>使用 Golang 开发，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。</li><li>多核并行。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。</li><li>从零造轮子。 几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能。</li><li>高效的内存利用。Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据(如 string -&gt; TS -&gt; JS -&gt; string)，造成内存的大量浪费。</li></ol><p>作为 Vite 的双引擎之一，Esbuild 在很多关键的构建阶段(如依赖预编译、TS 语法转译、代码压缩)让 Vite 获得了相当优异的性能。</p><ol><li><p>依赖预构建——作为 boundle 工具</p><p>vite 是提倡<code>no-bundle</code>的构建工具，单只是针对业务源码，第三方工具库还是需要打包的，但是是使用 Esbuild 来完成这一过程。为什么需要预构建呢？</p><ol><li>将其他格式例如 commonjs 转化为 esm 格式，使其可以在浏览器上正常加载</li><li>将第三方库的分散文件合并到一起，减少引入时的 http 请求。</li></ol><p>依赖预构建是自动开启的，可以在 node_modules 的.vite 目录里看到，并且 vite 的 dev serve 会对依赖设置强缓存，过期时间 1 年。如果以下三个地方没有改变，则一直使用缓存文件。</p><ol><li>package.json 里的依赖</li><li>lockfile</li><li>optimizeDeps 里的内容</li></ol></li><li><p>单文件编译——作为 ts 和 jsx 编译工具 作为 vite 插件，将 ts(x)和 js(x)单文件进行语法转译，这个插件功能在开发环境和生产环境都会执行，但其没有检查 ts 类型的功能，所以在 vite 构建脚本里有 tsc 命令，先做代码类型检查</p></li><li><p>压缩代码 共享 AST 和原生语言编写的压缩逻辑效率都比传统工具快极其多</p></li></ol><h4 id="esbuild-打包工具缺点" tabindex="-1">Esbuild 打包工具缺点 <a class="header-anchor" href="#esbuild-打包工具缺点" aria-label="Permalink to &quot;Esbuild 打包工具缺点&quot;">​</a></h4><ol><li>不支持降级到 es5</li><li>不支持 const enum 等语法</li><li>没提供操作打包产物的接口、钩子</li><li>不支持拆包策略</li></ol><h3 id="rollup-构建基石" tabindex="-1">Rollup - 构建基石 <a class="header-anchor" href="#rollup-构建基石" aria-label="Permalink to &quot;Rollup - 构建基石&quot;">​</a></h3><p>解决 esbuild 支持不了的功能，加上预加载、异步加载这些功能，并提供插件功能，自定义产出。vite 插件完全兼容 Rollup，反之不一定。</p><h2 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h2><p>关键点：</p><ol><li>快速冷启动：No Buonld + Esbuild 预构建</li><li>热更新模块：基于 ESM 的 HMR 和浏览器的缓存策略</li><li>真正的按需加载：利用浏览器的 ESM 支持，实现真正的按需加载</li></ol><h3 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h3><h4 id="开发阶段" tabindex="-1">开发阶段 <a class="header-anchor" href="#开发阶段" aria-label="Permalink to &quot;开发阶段&quot;">​</a></h4><ol><li>首先是基于 ESM 为核心， <ul><li>浏览器可以使用该模块，做 No Bounld 机制，</li><li>自带按需加载的机制 import，只有使用到时才去加载</li><li>同时会在本地会起一个 node 服务去拦截请求，并在响应头里添加强缓存、协商缓存的信息，在服务端使用自身插件和 Esbuild 对文件做 resolve load transform parse，然后以 ESM 模块返回给浏览器。做到了冷启动。</li></ul></li><li>其次是 Esbuild 的预构建机制 <ul><li>将其他格式的依赖转为 ESM 的</li><li>然后将分散的 import，整合成一个，减少模块请求。</li></ul></li><li>然后是实现热更新 HMR， <ul><li>基于 EMS HMR 规范实现了自己的一套 HMR API，用来做模块更新、旧模块失效、删除这些操作。</li><li>同时在服务中会创建依赖某块图，使用 chokidar 监听文件变化，监听到变化还是根据依赖图生产 HMR 边界模块，后续的更新操作只在 HMR 边界内生效。</li><li>页面访问后在客户端使用 websocket 建立连接，根据接收到的信息，由浏览器去加载变化的文件，做模块的操作。</li></ul></li></ol><h5 id="该阶段与-webpack-对比" tabindex="-1">该阶段与 webpack 对比 <a class="header-anchor" href="#该阶段与-webpack-对比" aria-label="Permalink to &quot;该阶段与 webpack 对比&quot;">​</a></h5><p>优势：</p><ol><li>更快的启动，利用 ESM 做 No_bounld，业务代码不编译，只做简单的分析转换。webpack 需要先构建再打包成 boundle</li><li>更快的热更新，还是利用了 ESM，只去更新边界内的模块，业务代码不编译，只做简单的分析转换。webpack 需要将相关依赖全部编译</li></ol><p>劣势：</p><ol><li>首屏很慢 <ul><li>预构建</li><li>需要转化为 ESM 模块，并且附带着大量的请求</li></ul></li><li>懒加载慢 <ul><li>需要转化为 ESM 模块，并且附带着大量的请求</li></ul></li><li>生态不如 webpack</li></ol><h4 id="生产阶段" tabindex="-1">生产阶段 <a class="header-anchor" href="#生产阶段" aria-label="Permalink to &quot;生产阶段&quot;">​</a></h4><ol><li>Rollup 打包</li></ol><h2 id="插件机制" tabindex="-1">插件机制 <a class="header-anchor" href="#插件机制" aria-label="Permalink to &quot;插件机制&quot;">​</a></h2><p>在开发阶段 vite 有部分 Hook 是和 Rollup 的 Hook 是通用的，再加上自己的独有 Hook；生产阶段则是和 Rollup 一样。</p><h3 id="通用-hook" tabindex="-1">通用 Hook: <a class="header-anchor" href="#通用-hook" aria-label="Permalink to &quot;通用 Hook:&quot;">​</a></h3><ul><li>服务器启动阶段：options 和 buildStart</li><li>请求响应阶段：resolved, load, transform</li><li>服务器关闭阶段：buildEnd, closeBundle</li></ul><h3 id="独有-hook" tabindex="-1">独有 Hook <a class="header-anchor" href="#独有-hook" aria-label="Permalink to &quot;独有 Hook&quot;">​</a></h3><ul><li>config: 用来进一步修改配置。</li><li>configResolved: 用来记录最终的配置信息。</li><li>configureServer: 用来获取 Vite Dev Server 实例，添加中间件。</li><li>transformIndexHtml: 用来转换 HTML 的内容。</li><li>handleHotUpdate: 用来进行热更新模块的过滤，或者进行自定义的热更新处理。</li></ul><h3 id="hook-执行顺序" tabindex="-1">Hook 执行顺序 <a class="header-anchor" href="#hook-执行顺序" aria-label="Permalink to &quot;Hook 执行顺序&quot;">​</a></h3><ul><li>服务启动阶段: config、configResolved、options、configureServer、buildStart</li><li>请求响应阶段: 如果是 html 文件，仅执行 transformIndexHtml 钩子；对于非 HTML 文件，则依次执行 resolveId、load 和 transform 钩子。相信大家学过 Rollup 的插件机制，已经对这三个钩子比较熟悉了。</li><li>热更新阶段: 执行 handleHotUpdate 钩子。</li><li>服务关闭阶段: 依次执行 buildEnd 和 closeBundle 钩子。</li></ul><h3 id="插件执行顺序" tabindex="-1">插件执行顺序 <a class="header-anchor" href="#插件执行顺序" aria-label="Permalink to &quot;插件执行顺序&quot;">​</a></h3><ul><li>Alias (路径别名)相关的插件。</li><li>带有 enforce: &#39;pre&#39; 的用户插件。</li><li>Vite 核心插件。</li><li>没有 enforce 值的用户插件，也叫普通插件。</li><li>Vite 生产环境构建用的插件。</li><li>带有 enforce: &#39;post&#39; 的用户插件。</li><li>Vite 后置构建插件(如压缩插件)。</li></ul><h2 id="与-webpack-的区别" tabindex="-1">与 webpack 的区别 <a class="header-anchor" href="#与-webpack-的区别" aria-label="Permalink to &quot;与 webpack 的区别&quot;">​</a></h2><p>vite 是双引擎架构，开发阶段和生产阶段涉及引擎使用不统一，所以要分开做对比</p><h3 id="开发阶段-1" tabindex="-1">开发阶段 <a class="header-anchor" href="#开发阶段-1" aria-label="Permalink to &quot;开发阶段&quot;">​</a></h3><ol><li>构建原理不一样 <ul><li>webpack 需要将所有依赖编译构建好标准 js 执行文件，再启动本地服务；</li><li>vite 业务代码构建，将第三方依赖预构建，页面访问时再去转换成 ESM 返回给浏览器执行，并带上浏览器缓存。</li></ul></li><li>HMR 实现不一样 <ul><li>webpack 监听到文件修改，构建成新模块，生成新的编译标识，然后旧就模块对比，确定更新部分，再通知浏览器根据标识获取到更新文件，浏览器执行文件，对模块进行替换更新删除；</li><li>vite 基于 ESM HDR 规范，对依赖分析出边界，生成 ESM 新模块，交给浏览器更新替换删。</li></ul></li></ol><h3 id="生产阶段-1" tabindex="-1">生产阶段 <a class="header-anchor" href="#生产阶段-1" aria-label="Permalink to &quot;生产阶段&quot;">​</a></h3><p>使用 Rollup 打包</p><ol><li>treeshaking 的实现逻辑不一样 <ul><li>webpack，先收集所以模块的导出值，形成导出列表，放到依赖图对象里去，然后再递归遍历模块标记哪些导出值使用到了哪些没使用到，按不同方式构建出代码后，使用工具将未使用的代码删除。</li><li>rollup，在将模块生成 AST 后，分析当前模块时，会定义出哪些是使用，哪些是未使用的变量。生成代码写时也只会，去将使用的变量加入字符串生成当中。实现 treeshaking</li></ul></li></ol>',44),r=[t];function d(n,h,u,s,c,p){return i(),e("div",null,r)}const m=l(o,[["render",d]]);export{k as __pageData,m as default};
