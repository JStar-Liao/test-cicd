import{_ as a,o as e,c as t,U as r}from"./chunks/framework.1bc6aac7.js";const m=JSON.parse('{"title":"js垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"面试经验/14-垃圾回收机制.md"}'),o={name:"面试经验/14-垃圾回收机制.md"},i=r(`<h1 id="js垃圾回收机制" tabindex="-1">js垃圾回收机制 <a class="header-anchor" href="#js垃圾回收机制" aria-label="Permalink to &quot;js垃圾回收机制&quot;">​</a></h1><p>栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理 js自己有套垃圾回收机制，开发人员不用关心内存分配和回收问题，但要知道其机制</p><h2 id="不被回收的固有值" tabindex="-1">不被回收的固有值 <a class="header-anchor" href="#不被回收的固有值" aria-label="Permalink to &quot;不被回收的固有值&quot;">​</a></h2><ol><li>本地函数的局部变量和参数</li><li>全局变量 (所以为什么要注意)</li><li>内部的</li></ol><h2 id="回收机制" tabindex="-1">回收机制 <a class="header-anchor" href="#回收机制" aria-label="Permalink to &quot;回收机制&quot;">​</a></h2><p>基于&#39;可达性&#39;概念，活在作用域中。</p><h3 id="标记清除法" tabindex="-1">标记清除法 <a class="header-anchor" href="#标记清除法" aria-label="Permalink to &quot;标记清除法&quot;">​</a></h3><pre><code>当进入作用域，局部变量打上进入的标签，垃圾回收时对进入状态的变量永远不会清除，当作用域结束时，局部变量打上结束标签，下一次垃圾回收时，就会被干掉
</code></pre><h3 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h3><pre><code>声明一个引用类型时，标记其引用为0，然后跟踪这个引用类型，当这个引用类型地址赋值给变量时引用标记+1，当变量改变值之后，引用标记-1，当0时，下一次垃圾回收时被干掉
</code></pre>`,10),s=[i];function l(n,_,c,d,h,p){return e(),t("div",null,s)}const f=a(o,[["render",l]]);export{m as __pageData,f as default};
