import{_ as e,o as t,c as a,U as i}from"./chunks/framework.1bc6aac7.js";const v=JSON.parse('{"title":"vue 状态管理","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue-base/状态管理.md"}'),o={name:"vue/vue-base/状态管理.md"},l=i('<h1 id="vue-状态管理" tabindex="-1">vue 状态管理 <a class="header-anchor" href="#vue-状态管理" aria-label="Permalink to &quot;vue 状态管理&quot;">​</a></h1><h3 id="pinia-实现原理" tabindex="-1">pinia 实现原理 <a class="header-anchor" href="#pinia-实现原理" aria-label="Permalink to &quot;pinia 实现原理&quot;">​</a></h3><ol><li>利用 vue 的 use，调用 pinia 提供的 install 方法，通过 vue 的 provide，将当前 pinia 实例注册到每个组件实例里去。</li><li>当业务里使用 usexx 时，会调用 pinia 内部方法，defineStore 去初始化仓库 store 对象</li><li>首先根据参数类别，利用 TS 函数重载，执行不同的方法处理 options 参数和 id，</li><li>然后将 state 利用 composition api 做响应式处理和转换，然后挂载到 store 上面</li><li>再把 pinia 的 api 挂载到 store 上面</li><li>挂载完在执行 pinia 的插件，去修改 store</li><li>最后将这个 Store 返回出去</li></ol><h4 id="storetoref" tabindex="-1">storeToRef <a class="header-anchor" href="#storetoref" aria-label="Permalink to &quot;storeToRef&quot;">​</a></h4><h3 id="vuex-原理" tabindex="-1">vuex 原理 <a class="header-anchor" href="#vuex-原理" aria-label="Permalink to &quot;vuex 原理&quot;">​</a></h3><ol><li>利用 vue 的 use 方法，vuex 提供 install 方法，vue 将 vuex 对象，通过$options 挂载到 vue 组件全局。</li><li>利用 new Vue 实例，创建响应式 data，然后 vuex 类内部创建 get state 方法，返回这个 vue 实例的 data</li><li>getter 方法，则是遍历 getter 内部的方法，使用 object.definePropty，劫持 get 方法，内部将 state 当做参数，传入 getter 里的每个方法，执行，然后 return 出去。这个操作，让 getter 方法不用执行就可以拿到结果</li><li>mutation 方法，遍历所有方法对象，然后重新赋值为一个新的单参数函数，函数在内部将 state 和外部的参数，代入到 mutation 的每个方法，执行。</li><li>提供 commit 方法，接受 mutation 的方法名和修改的数据值参数，内部通过获取 mutation 方法，代入数据值参数，执行</li><li>actions 方法，和 commit 类似，生成的单参数函数内部，会传入 this 和修改的数据值参数</li></ol><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ol><li>去掉了 mutaions 属性，同时提供了$reset,$onActions 这类 API</li></ol>',8),r=[l];function n(s,u,c,d,h,_){return t(),a("div",null,r)}const m=e(o,[["render",n]]);export{v as __pageData,m as default};
