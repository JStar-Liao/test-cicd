import{_ as e,o as a,c as t,U as o}from"./chunks/framework.1bc6aac7.js";const p=JSON.parse('{"title":"vue 的 watch 和 computed","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue-base/z_watch和computed的实现.md"}'),c={name:"vue/vue-base/z_watch和computed的实现.md"},l=o('<h1 id="vue-的-watch-和-computed" tabindex="-1">vue 的 watch 和 computed <a class="header-anchor" href="#vue-的-watch-和-computed" aria-label="Permalink to &quot;vue 的 watch 和 computed&quot;">​</a></h1><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><h2 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h2><ol><li>是一个数据监听属性，数据有变化会触发 handle 的执行回调函数</li><li>有 deep 属性可以设置，深度监听元素变化，默认是 false， 只监听对象自身，不监听其内元素值改变 0，true，监听子属性变化，但还是受制于 Object.defineProperty 的不监听属性的增加</li><li>不监听未被 observer 劫持的对象</li></ol><h2 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h2><ol><li>要依赖 data 上的属性变化返回一个值，watch 则是观察数据触发回调</li><li>再次引用该变量，如果关联的劫持变量没改变，会从缓存中拿</li><li>内部不能操作异步函数，会提示错误</li><li>有 get 和 set 方法，set 内可以使用异步函数</li><li>只监听对象自身，不监听其内元素值改变</li><li>computed 和 watch 依赖收集的发生点不同，c 渲染时，watch 渲染前</li></ol><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2>',7),i=[l];function r(h,d,u,s,n,_){return a(),t("div",null,i)}const w=e(c,[["render",r]]);export{p as __pageData,w as default};
