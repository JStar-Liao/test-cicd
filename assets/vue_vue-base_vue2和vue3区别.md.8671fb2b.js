import{_ as l,o as s,c as a,U as e}from"./chunks/framework.1d5623bb.js";const v=JSON.parse('{"title":"vue2 和 vue3 区别","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue-base/vue2和vue3区别.md"}'),n={name:"vue/vue-base/vue2和vue3区别.md"},o=e(`<h1 id="vue2-和-vue3-区别" tabindex="-1">vue2 和 vue3 区别 <a class="header-anchor" href="#vue2-和-vue3-区别" aria-label="Permalink to &quot;vue2 和 vue3 区别&quot;">​</a></h1><h2 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-label="Permalink to &quot;主要区别&quot;">​</a></h2><ol><li>工程源码</li></ol><ul><li>工程目录 v3 改成了 monorepo 方式维护，v2 是在 src 目录下根据功能拆分。 <ul><li>让开发人员更容易理解、更改模块</li><li>让包可以单独引用，而不用依赖整个 vuejs，比如响应式库</li></ul></li><li>类型检查工具改成了 typescript，也就是使用 ts 重写，v2 是使用的是 Flow <ul><li>可以更好结合 ts 做开发</li></ul></li></ul><ol start="2"><li>性能</li></ol><ul><li>源码体积优化，移除了一些冷门的功能比如（filter，inline-template），还有引入了 tree-shaking 技术</li><li>编译优化，v3 在编译阶段会对静态模板分析，会将不需要动态更新的节点生成 Block tree，只去 diff 绑定动态节点的标签。</li></ul><ol start="3"><li>数据劫持修改</li></ol><ul><li>v3 是使用 proxy api 劫持数据的，而 vue2 使用的是 object.definePropty。proxy 提供更多的监听方法，可以劫持的是整个对象属性的增删改。 <ul><li>注意点 <ol><li>proxy 不能监听内部深层次的对象变化，v3 是在 proxy 的 getter 里做递归劫持，这样做好处是只有使用了这个对象才去劫持</li></ol></li><li>解决了不能检测到对象属性添加删除的缺陷</li><li>解决一开始旧遍历劫持对象层次耗性能的问题</li><li>还代理了 set、map、weakmap、weakset</li><li>依赖项的收集是用 WeakMap 类型收集，已 target 为键，Set 类型收集 effect 列表。 <ul><li>好处，target 不在被引用时，其值的列表项也会被自动回收。具有更好的内存管理</li></ul></li></ul></li></ul><ol start="4"><li>api</li></ol><ul><li><p>提供了 Composition API（组合式 api）</p><ul><li>逻辑点不会怎么分散</li><li>码更易于复用和组合</li></ul></li><li><p>$on，$off 和 $once 被移除</p></li></ul><ol start="5"><li>新组件</li></ol><ul><li>Teleport，模态框组件，将内部 dom 插入到指定标签、id、类名下面去</li></ul><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">Teleport</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">to</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">&gt;DOM&lt;/</span><span style="color:#FDAEB7;font-style:italic;">Teleport</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>Suspense，异步处理组件，在加载异步组件时，可以先渲染其它东西，让渲染更加平滑</li></ul><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">#default</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">async-component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">#fallback</span><span style="color:#E1E4E8;">&gt; Loading... &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#FDAEB7;font-style:italic;">suspense</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="6"><li>diff 算法</li></ol><ul><li><p>v3 在编译时使用了静态节点提前处理的方式（静态节点提升），做了静态标记，更新不重新计算和比较</p></li><li><p>最长子序列的索引</p><ol><li>子节点比较</li></ol><ul><li>vue2 使用双端比较法，头和头、尾和尾、头和尾、尾和头，匹配到再位移起始结束节点下标，然后再利用 key，循环比较看有没有可以复用的节点，然后移动。</li><li>vue3 使用双端比较头和头、尾和尾，匹配到再位移起始结束下标，剩余新节点的会生成 keyMap，然后根据 key 生成一个对应再旧节点数组的下标，再遍历一遍旧节点，将 key 相同的做差异比对，再最终移动替换节点时，会使用贪心算法加二分查找法，得到最长子序列的索引，添加、替换期间会记录前一个索引是谁，然后在使用前置朔源法，归正乱序。然后遍历新节点数组，参照节点下标数组做位置替换，如果遍历下标匹配待最长子序列的索引，则不替换。然后再新增删除对应的节点。</li></ul><ol start="2"><li>静态节点提升</li></ol><ul><li>vue3 编译时会记录不包含数据劫持的标签节点，在更新直接使用这些节点。同时再 diff 对比时直接跳过这些节点。</li></ul></li></ul><ol start="7"><li>生命周期</li></ol><ul><li>组合式 api 的生命周期钩子 4. onBeforeMount 在组件被挂载之前被调用 <ol><li>onMounted 在组件挂载完成后执行。</li><li>onBeforeUpdate 在组件即将因为响应式状态变更而更新其 DOM 树之前调用</li><li>onUpdated 在组件因为响应式状态变更而更新其 DOM 树之后调用。</li><li>onBeforeUnmount 在组件实例被卸载之前调用</li><li>onUnmounted 在组件实例被卸载之后调用</li><li>onErrorCaptured 在捕获了后代组件传递的错误时调用</li><li>onRenderTracked 当组件渲染过程中追踪到响应式依赖时调用</li><li>onRenderTriggered 当响应式依赖的变更触发了组件渲染时调用</li><li>onActivated 组件实例是 KeepAlive 缓存树的一部分，当组件被插入到 DOM 中时调用</li><li>onDeactivated 若组件实例是 KeepAlive 缓存树的一部分，当组件从 DOM 中被移除时调用</li><li>onServerPrefetch 在组件实例在服务器上被渲染之前调用</li></ol></li></ul><ol start="8"><li><p>v-if/v-for 的实现</p></li><li><p>多根节点处理 jsx 的写法还是一个，遵循 jsx 规范</p></li></ol>`,20),t=[o];function p(i,r,c,E,u,y){return s(),a("div",null,t)}const m=l(n,[["render",p]]);export{v as __pageData,m as default};
