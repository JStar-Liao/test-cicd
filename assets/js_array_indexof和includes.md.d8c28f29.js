import{_ as e,o as a,c as i,U as n}from"./chunks/framework.1d5623bb.js";const x=JSON.parse('{"title":"indexOf 和 includes","description":"","frontmatter":{},"headers":[],"relativePath":"js/array/indexof和includes.md"}'),o={name:"js/array/indexof和includes.md"},d=n('<h1 id="indexof-和-includes" tabindex="-1">indexOf 和 includes <a class="header-anchor" href="#indexof-和-includes" aria-label="Permalink to &quot;indexOf 和 includes&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>都是用来检查字符串或数组中是否包含某个元素的方法，但它们在使用和返回值上有一些重要的区别</p><h2 id="includes" tabindex="-1">includes <a class="header-anchor" href="#includes" aria-label="Permalink to &quot;includes&quot;">​</a></h2><p>arr.includes(基本类型或者变量)，返回 boolean 值</p><ol><li>能检测 NaN，因为内部使用 SameValueZero 算法比较，它认为 NaN 等于自身</li></ol><h2 id="indexof" tabindex="-1">indexOf <a class="header-anchor" href="#indexof" aria-label="Permalink to &quot;indexOf&quot;">​</a></h2><p>arr.indexOf(基本类型或者变量，开始检索位置（可选参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1）),返回下标和-1</p><ol><li>只关心元素存不存在，不关心位置，includes 可能会更快些，因为它匹配到第一项就会停止</li></ol>',9),t=[d];function l(r,s,c,u,_,h){return a(),i("div",null,t)}const p=e(o,[["render",l]]);export{x as __pageData,p as default};
