import{_ as s,o as a,c as n,U as l}from"./chunks/framework.1d5623bb.js";const _=JSON.parse('{"title":"作用域","description":"","frontmatter":{},"headers":[],"relativePath":"面试经验/17-作用域.md"}'),e={name:"面试经验/17-作用域.md"},p=l(`<h1 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h1><p>控制变量和函数的可见范围和生命周期称为作用域。js内的作用域是静态作用域，并不会因为在其他作用域运行，就调用其他作用域内的变量，而是调用定义其作用域的变量</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">9</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">b</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(a)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">c</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">88</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">b</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 打印 9</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">c</span><span style="color:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h1 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h1><p>多个作用域的对象列表，用来执行上下文的检索标识符（变量名，参数，函数名）</p><h2 id="作用域的形成" tabindex="-1">作用域的形成 <a class="header-anchor" href="#作用域的形成" aria-label="Permalink to &quot;作用域的形成&quot;">​</a></h2><ol><li>在执行上下文阶段，遇到函数声明时，在创建阶段，汇报父级的变量对象集合保存到内部属性[[ scope ]]中，这个集合称之为作用域链</li><li>然后在运行激活阶段，会复制[[ scope ]]，然后创建自身的变量对象加入到其作用链中</li></ol>`,7),o=[p];function r(c,t,i,E,y,b){return a(),n("div",null,o)}const u=s(e,[["render",r]]);export{_ as __pageData,u as default};
