import{_ as a,o as e,c as t,U as i}from"./chunks/framework.1bc6aac7.js";const m=JSON.parse('{"title":"箭头函数与普通函数区别","description":"","frontmatter":{},"headers":[],"relativePath":"js/base/箭头函数与普通函数区别.md"}'),o={name:"js/base/箭头函数与普通函数区别.md"},l=i('<h1 id="箭头函数与普通函数区别" tabindex="-1">箭头函数与普通函数区别 <a class="header-anchor" href="#箭头函数与普通函数区别" aria-label="Permalink to &quot;箭头函数与普通函数区别&quot;">​</a></h1><h2 id="箭头函数定义" tabindex="-1">箭头函数定义 <a class="header-anchor" href="#箭头函数定义" aria-label="Permalink to &quot;箭头函数定义&quot;">​</a></h2><p>箭头函数表达式的语法比传统的函数表达式更简洁，但在语义上有一些差异，在用法上也有一些限制：</p><p>箭头函数没有独立的 <code>this</code>、<code>arguments</code> 和 <code>super</code> 绑定，并且不可被用作方法。 箭头函数不能用作构造函数。使用 new 调用它们会引发 TypeError。它们也无法访问 <code>new.target</code> 关键字。 箭头函数不能在其主体中使用 <code>yield</code>，也不能作为生成器函数创建。</p><h2 id="好处" tabindex="-1">好处 <a class="header-anchor" href="#好处" aria-label="Permalink to &quot;好处&quot;">​</a></h2><ol><li><p>更简洁的语法： 箭头函数提供了一种更简洁的方式来编写函数，特别是当函数体很短或者不需要自己的 this、arguments 或 super 时。 传统函数：</p></li><li><p>不绑定自己的 this： 箭头函数不会创建自己的 this 上下文，所以 this 的值继承自包围它的函数执行上下文（在非严格模式下）或全局对象（在严格模式下）。这使得在回调函数、事件处理器或任何不期望或不方便创建新 this 上下文的地方使用箭头函数特别有用。</p></li></ol><ol start="6"><li>更少的错误： 由于箭头函数不绑定自己的 this，它们减少了因错误地引用 this 而导致的错误。这使得它们在处理回调函数和事件监听器时特别有用。</li></ol><h2 id="弊端" tabindex="-1">弊端 <a class="header-anchor" href="#弊端" aria-label="Permalink to &quot;弊端&quot;">​</a></h2><h2 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h2><ol><li>this 指向</li><li>没有 prototype 属性 不能作为构造函数</li><li>不能再其中使用 yield 关键字</li><li>没有自己的 arguments 对象。但是，你可以使用剩余参数（...args）来替代它</li></ol><h2 id="与普通函数区别" tabindex="-1">与普通函数区别 <a class="header-anchor" href="#与普通函数区别" aria-label="Permalink to &quot;与普通函数区别&quot;">​</a></h2><ol><li>箭头函数的<code>this</code>指向其定义时的所在的函数对象，bind、aplly、call 显示绑定也无法改变</li><li>不能作为构造函数</li><li>没有 arguments 对象</li></ol>',12),r=[l];function s(d,h,c,n,_,p){return e(),t("div",null,r)}const b=a(o,[["render",s]]);export{m as __pageData,b as default};
